#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#define LISTEN_PORT 1337
#define PORT 1337

extern char **environ;
int ssock;
int fork_sock;
char *welcome = "                      :::!~!!!!!:.\n\
                  .xUHWH!! !!?M88WHX:.\n\
                .X*#M@$!!  !X!M$$$$$$WWx:.\n\
               :!!!!!!?H! :!$!$$$$$$$$$$8X:\n\
              !!~  ~:~!! :~!$!#$$$$$$$$$$8X:\n\
             :!~::!H!<   ~.U$X!?R$$$$$$$$MM!\n\
             ~!~!!!!~~ .:XW$$$U!!?$$$$$$RMM!\n\
               !:~~~ .:!M\"T#$$$$WX??#MRRMMM!\n\
               ~?WuxiW*`   `\"#$$$$8!!!!??!!!\n\
             :X- M$$$$       `\"T#$T~!8$WUXU~\n\
            :%`  ~#$$$m:        ~!~ ?$$$$$$\n\
          :!`.-   ~T$$$$8xx.  .xWW- ~"
                "##*\"\n\
.....   -~~:<` !    ~?T#$$@@W@*?$$      /`\n\
W$@@M!!! .!~~ !!     .:XUW$W!~ `\"~:    :\n\
#\"~~`.:x%`!!  !H:   !WM$$$$Ti.: .!WUn+!`\n\
:::~:!!`:X~ .: ?H.!u \"$$$B$$$!W:U!T$$M~\n\
.~~   :X@!.-~   ?@WTWo(\"*$$$W$TH$! `\n\
Wi.~!X$?!-~    : ?$$$B$Wu(\"**$RM!\n\
$R@i.~~ !     :   ~$$$$$B$$en:``\n\
?MXT@Wx.~    :     ~\"##*$$$$M~\n\
\nWelcome to the 1337 Exploit Checker\n";

struct Target
{
  char hostname[16];
  void (*delete_structure)(struct Target *, int *);
  uint16_t arch;
  uint16_t operating_system;
};

struct Exploit
{
  char name[16];
  uint16_t arch;
  uint16_t operating_system;
  uint16_t version;
  uint16_t type;
};

void delete_structure(struct Target *s1, int *pcsock)
{
  send(*pcsock, "Deleting structure!\n", 21, 0);
  free(s1);
}

struct Target *newS1(int *pcsock)
{
  struct Target *s1 = malloc(sizeof(struct Target));
  char arch[17];
  char operating_system[17];
  send(*pcsock, "What is the hostname?\n", 23, 0);
  recv(*pcsock, s1->hostname, 16, 0);
  s1->delete_structure = delete_structure;
  send(*pcsock, "What is the architecture?\n", 27, 0);
  recv(*pcsock, arch, 16, 0);
  s1->arch = atoi(arch);
  send(*pcsock, "What is the os?\n", 17, 0);
  recv(*pcsock, operating_system, 16, 0);
  s1->operating_system = atoi(operating_system);

  return s1;
}

struct Exploit *newS2(int *pcsock)
{
  char arch[17];
  char operating_system[17];
  char version[17];
  char type[17];
  struct Exploit *s2 = malloc(sizeof(struct Exploit));
  send(*pcsock, "What is the name of the exploit?\n", 34, 0);
  recv(*pcsock, s2->name, 16, 0);
  send(*pcsock, "What is the architecture?\n", 27, 0);
  recv(*pcsock, arch, 16, 0);
  s2->arch = atoi(arch);
  send(*pcsock, "What is the os?\n", 17, 0);
  recv(*pcsock, operating_system, 16, 0);
  s2->operating_system = atoi(operating_system);
  send(*pcsock, "What is the version?\n", 22, 0);
  recv(*pcsock, version, 16, 0);
  s2->version = atoi(version);
  send(*pcsock, "What is the type?\n", 19, 0);
  recv(*pcsock, type, 16, 0);
  s2->type = atoi(type);

  return s2;
}

void check_compatability(struct Target *s1, struct Exploit *s2, int *pcsock)
{
  if((s1->arch == s2->arch) && (s1->operating_system == s2->operating_system)&&(s2->version >0)){
    send(*pcsock,"Valid Exploit for Target\n",26,0);
  } else{
    send(*pcsock,"Invalid Exploit for Target\n",28,0);
  }
  return;
}

void retrieve_admin_key()
{
  char *test_pass = "aaaaaaaaaaaaaaaa";
  char *pass = "s!5jr7myXTUZ!^@E";
  send(fork_sock, "What is the password?\n", 23, 0);
  recv(fork_sock, test_pass, 16, 0);
  if (strcmp(pass, test_pass) == 0)
  {
    send(fork_sock, "flag{r3M0t3-Use-Aft3r-Fr33-B@bY}\n", 34, 0);
  }
  else
  {
    send(fork_sock, "Bad Password\n", 14, 0);
  }
  return;
}

void recv_loop(int csock)
{
  struct Target *s1 = NULL;
  struct Exploit *s2 = NULL;
  char trash[10];
  char action;
  int *pcsock = &csock;
  fork_sock = *pcsock;
  setreuid(geteuid(), geteuid());
  send(*pcsock, welcome, 855, 0);
  while (1)
  {

    send(*pcsock, "1: Make a Target\n2: Delete a Target\n3: Create an Exploit\n4: Check Exploit Compatability\n5: Retrieve Admin Key  \n6: Exit\n", 121, 0);
    recv(*pcsock, &action, 1, 0);
    recv(*pcsock, &trash, 10, 0);
    switch (action)
    {
    case 0:
    case '1':
      s1 = newS1(pcsock);
      break;
      break;
    case '2':
      if (!s1)
      {
        send(*pcsock, "No target?\n", 12, 0);
        break;
      }
      s1->delete_structure(s1, pcsock);
      break;
    case '3':
      s2 = newS2(pcsock);
      break;
    case '4':
      check_compatability(s1,s2, pcsock);
      break;
    case '5':
      retrieve_admin_key();
      break;
    case '6':
    default:
      return;
    }
  }
  return;
}

void *handle_socket(int *pcsock)
{
  recv_loop(pcsock);
  close(*pcsock);
  free(pcsock);

  return NULL;
}

int main(){

	int sockfd, ret;
	 struct sockaddr_in serverAddr;

	int newSocket;
	struct sockaddr_in newAddr;

	socklen_t addr_size =sizeof(newAddr);

	char buffer[1024];
	pid_t childpid;

	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if(sockfd < 0){
		printf("[-]Error in connection.\n");
		exit(1);
	}
	printf("[+]Server Socket is created.\n");

	memset(&serverAddr, '\0', sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_port = htons(PORT);
	serverAddr.sin_addr.s_addr = inet_addr("0.0.0.0");

	ret = bind(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr));
	if(ret < 0){
		printf("[-]Error in binding.\n");
		exit(1);
	}
	printf("[+]Bind to port %d\n", PORT);

	if(listen(sockfd, 10) == 0){
		printf("[+]Listening....\n");
	}else{
		printf("[-]Error in binding.\n");
	}


	while(1){
		newSocket = accept(sockfd, (struct sockaddr*)&newAddr, &addr_size);
		if(newSocket < 0){
			exit(1);
		}
		printf("Connection accepted from %s:%d\n", inet_ntoa(newAddr.sin_addr), ntohs(newAddr.sin_port));

		if((childpid = fork()) == 0){
			close(sockfd);

    recv_loop(newSocket);
		}

	}

	close(newSocket);


	return 0;
}